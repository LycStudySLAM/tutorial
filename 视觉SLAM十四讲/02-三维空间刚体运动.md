# 三维空间刚体运动

以下内容为高翔《视觉SLAM十四讲》第二版的学习笔记

## 回顾

上一讲简单介绍了SLAM是什么，一个经典视觉SLAM框架由哪几个模块组成，也了解了SLAM的核心是定位与建图。既然需要定位，那必然要构建位置与姿态的数学描述。本讲主要介绍三维空间刚体运动的数学描述。

## 数学基础

### 向量

本书中向量默认为n维列向量，n维行向量是其转置

向量内积
$$
a·b=a^Tb=\displaystyle\sum\limits_{i=1}^n a_ib_i
$$
向量外积（以三维外积为例）
$$
a\times b= \begin{bmatrix}e_1&e_2&e_3\\a_1&a_2&a_3\\b_1&b_2&b_3\end{bmatrix}=
\begin{bmatrix}0&-a_3&a_2\\a_3&0&-a_1\\-a_2&a_1&0\end{bmatrix}b=a^{\wedge}b
$$

其中：
$$
a^{\wedge}=\begin{bmatrix}0&-a_3&a_2\\a_3&0&-a_1\\-a_2&a_1&0\end{bmatrix}
$$
被称为列向量a的反对称矩阵，注意：反对称矩阵A满足如下性质:
$$
A^T=-A
$$

### 坐标与坐标系

$$
n维线性空间下的一组基底(e_1,e_2,...,e_n),这是一组线性无关的向量\\
对于n维空间的任意一个向量a，就可以由基底进行如下的表示:\\
a = [e_1,e_2,e_3]\begin{bmatrix}a_1\\a_2\\a_3\end{bmatrix},
(a_1,a_2,a_3)^T称为向量a在该基底下的坐标\\
坐标系则一般是一组正交的线性无关的向量
$$

## 坐标系间的欧式变换

设想一下，我们如若获得了相机当前的位姿（称为相机坐标系），同时以相机的初始位姿作为世界坐标系，如何将相机视野里的某个向量由相机坐标系下的坐标变换到世界坐标下？这就需要进行坐标系间的变换。所谓欧式变换，则是指在刚体运动过程中，向量在各个坐标系内的长度与角度不会发生变化。

![02-1](C:\Users\legions\Desktop\research_notes\视觉SLAM十四讲\img\02-1.png)

简便起见，先讨论旋转而忽略平移。记两组原点在同一位置上的基底，分别为e和e‘，同一个向量在两组基底下的坐标分别为a和a’，显然对于同一个向量，是无关坐标系的，所以有
$$
\begin{bmatrix}e_1&e_2&e_3\end{bmatrix}\begin{bmatrix}a_1\\a_2\\a_3\end{bmatrix}
= \begin{bmatrix}e_1'&e_2'&e_3'\end{bmatrix}\begin{bmatrix}a_1'\\a_2'\\a_3'\end{bmatrix}
$$
两边同时左乘一个列向量如下
$$
\begin{bmatrix}e_1^T\\e_2^T\\e_3^T\end{bmatrix}\begin{bmatrix}e_1&e_2&e_3\end{bmatrix}\begin{bmatrix}a_1\\a_2\\a_3\end{bmatrix}= \begin{bmatrix}e_1^T\\e_2^T\\e_3^T\end{bmatrix}\begin{bmatrix}e_1'&e_2'&e_3'\end{bmatrix}\begin{bmatrix}a_1'\\a_2'\\a_3'\end{bmatrix}
$$
由矩阵乘法可以得到
$$
\begin{bmatrix}e_1^Te_1&e_1^Te_2&e_1^Te_3\\e_2^Te_2&e_2^Te_2&e_2^Te_3\\e_3^Te_3&e_3^Te_2&e_3^Te_3\end{bmatrix}
\begin{bmatrix}a_1\\a_2\\a_3\end{bmatrix}= \begin{bmatrix}e_1^Te_1'&e_1^Te_2'&e_1^Te_3'\\e_2^Te_2'&e_2^Te_2'&e_2^Te_3'\\e_3^Te_3'&e_3^Te_2'&e_3^Te_3'\end{bmatrix}
\begin{bmatrix}a_1'\\a_2'\\a_3'\end{bmatrix}
$$
对于矩阵
$$
\begin{bmatrix}e_1^Te_1&e_1^Te_2&e_1^Te_3\\e_2^Te_1&e_2^Te_2&e_2^Te_3\\e_3^Te_1&e_3^Te_2&e_3^Te_3\end{bmatrix}
$$
由于e是一组线性无关的基底，而式中相当于在求基中各个线性无关向量的点乘，而线性无关时，一个向量在另一个向量上的投影为0，所以只有主对角线上的三个值为1，其余为0。也就是说，这是一个单位矩阵。

所以原式变为了
$$
\begin{bmatrix}a_1\\a_2\\a_3\end{bmatrix}= \begin{bmatrix}e_1^Te_1'&e_1^Te_2'&e_1^Te_3'\\e_2^Te_2'&e_2^Te_2'&e_2^Te_3'\\e_3^Te_3'&e_3^Te_2'&e_3^Te_3'\end{bmatrix}
\begin{bmatrix}a_1'\\a_2'\\a_3'\end{bmatrix}
$$
其中
$$
R=\begin{bmatrix}e_1^Te_1'&e_1^Te_2'&e_1^Te_3'\\e_2^Te_2'&e_2^Te_2'&e_2^Te_3'\\e_3^Te_3'&e_3^Te_2'&e_3^Te_3'\end{bmatrix}
$$
称R为**旋转矩阵**，该矩阵必为正交矩阵，即其逆与其转置矩阵是一致的，且行列式为1

把n维旋转矩阵记作一个集合SO(n)，称为特殊正交群
$$
SO(n)=\{R\in R^{n\times n}|RR^T=I,det(R)=1\}
$$
这样就得到了一个坐标变换方程：
$$
a = Ra'
$$
相反的变换也很容易得到：
$$
a' = R^{-1}a=R^Ta
$$

## 三维刚体运动方程

上面的推导已经描述了坐标系旋转的问题，现在将平移也加入进来。

记两个坐标系1,2。

从坐标系1到坐标系2的旋转矩阵为R21，从坐标系2到坐标系1的旋转矩阵为R12。

从坐标系1原点到坐标系2原点的向量在坐标系1下的坐标为t12，从坐标系2原点到坐标系1原点的向量在2坐标系2的坐标为t21

向量a在坐标系1下的坐标为a1，在坐标系2下的坐标为a2，则有
$$
a_1=R_{12}a_2+t_{12}\\
a_2=R_{21}a_1+t_{21}
$$
其中务必注意，t12并不一定等于-t21，它仅在特殊状况下成立（比如两坐标系无旋转或无平移等），因为这是在不同坐标系下的坐标，对于向量本身是相反的，但是在经过旋转的坐标系下的坐标表示就不满足了。可以通过画简单的示意图理解这一点。

如此一来，依靠旋转矩阵R和平移向量t，可以唯一得到一个坐标系变换。

不过还有一个小问题，多次进行变换时，会产生类似如下的式子，计算不够闭合,可以想象若干次后的形式该有多繁杂。
$$
b=R_1a+t_1,c=R_2b+t_2,则c=R_2(R_1a+t_1)+t_2
$$


故而引入齐次形式
$$
\begin{bmatrix}a'\\1\end{bmatrix}=
\begin{bmatrix}R&t\\0^T&1\end{bmatrix}
\begin{bmatrix}a\\1\end{bmatrix}
$$
记**变换矩阵**
$$
T=\begin{bmatrix}R&t\\0^T&1\end{bmatrix}
$$
则可以多次左乘变换矩阵T来表示多次的变换，相较于之前的表示法更为方便。

这类变换矩阵也可以称为一个集合，叫做特殊欧式群
$$
SE(3)=\{T=\begin{bmatrix}R&t\\0^T&1\end{bmatrix} \in R^{4\times 4}|
R\in SO(3),t\in R^3\}
$$
求解该矩阵的逆也可以用于表示一个反向的变换
$$
T^{-1}=\begin{bmatrix}R^T&-R^Tt\\0^T&1\end{bmatrix}
$$


## 旋转的其他表示法

### 旋转向量

为了简单的表示旋转，并且不受旋转矩阵为正交矩阵这一约束，引入旋转向量这一表示。

旋转向量采用向量n表示旋转轴的方向，θ表示绕该旋转轴旋转的角度，那么，称θn为旋转向量，这仅仅用了三个量就表示了旋转。

它与旋转矩阵的关系为
$$
R=\cos\theta I+(1-\cos\theta)nn^T+\sin\theta  n^\wedge \\
$$
该式称为罗德里格斯公式，这一公式给出了旋转向量和旋转矩阵之间的关系，证明将在后续李群与李代数一块进行证明。

对上式两边求迹（矩阵的迹为对角线元素和），有
$$
tr(R)=3\cos\theta+(1-\cos\theta)=2\cos\theta+1\\
$$
简单证明如下
$$
tr(I)=1+1+1=3\\
记n=(a,b,c)，且n的模为1，则\\
nn^T=\begin{bmatrix}a^2&ab&ac\\ba&b^2&bc\\ca&cb&c^2\end{bmatrix}\\
tr(nn^T)=a^2+b^2+c^2=1\\
tr(n\wedge)=0+0+0=0\\
从而\quad tr(R)=3\cos\theta+(1-\cos\theta)=2\cos\theta+1
$$
由上式可得
$$
\theta = arccos(\frac{tr(R)-1}{2})\\
$$
这个式子说明可以由旋转矩阵R直接得到相对于旋转轴n的旋转角θ

由于转轴上的向量在旋转后不变，故而
$$
Rn=n
$$
这说明了n是R特征值1的特征向量，求解此方程再归一化则可以得到旋转轴向量。

关于旋转向量，将在下一讲李群与李代数中更深入地讨论。

### 欧拉角

使用偏航-俯仰-横滚(yaw-pitch-roll)来描述一个旋转，记一个刚体前方为X轴，右侧为Y轴，上方为Z轴，通过ZYX三次旋转来表达总的旋转，用[r,p,y]的转置这样一个向量来描述任意旋转。旋转的方式是：先绕Z轴旋转，再绕**旋转后**的Y轴旋转，再绕**旋转后**的X轴旋转。

![02-2](C:\Users\legions\Desktop\research_notes\视觉SLAM十四讲\img\02-2.png)

但是，简单归简单，这个过程还是有可能碰到问题的，因为它的转轴是固定以ZYX顺序进行旋转的，如果Y旋转了±90°，可以预见，X旋转时实际上在和第一步的Z用的是物理实际上的同一个轴，这就丢失了一个自由度，这个问题也被称为万向锁问题。（读者可以转一转自己的手机试一试，会有更好的理解）

上面所说的旋转向量和欧拉角都具有奇异性，准确地说，尝试使用一个三维向量表达三个自由度的旋转，都不可避免地具有奇异性（旋转向量表现为θ超过[0,2π]范围的周期性，欧拉角体现在万向锁问题）

### 四元数

事实上，旋转没有不具有奇异性的三维向量的描述。旋转矩阵采用九个量表示，冗余较大，旋转向量和四元数又过于紧凑，导致具有奇异性问题。因此引入四元数这一概念进行表示，它使用四个量无奇异性的表示旋转。

#### 定义

$$
q=q_0+q_1i+q_2j+q_3k\\
i^2=j^2=k^2=-1\\
ij=k,jk=i,ki=j\\
ji=-k,kj=-i,ik=-j
$$

也可以分为实部和虚部，表达为
$$
q=[s,v]^T,s=q_0\in R,v=[q_1,q_2,q_3]^T\in R^3
$$
#### 运算性质

$$
q_a=s_a+x_ai+y_aj+z_ak\quad\quad q_b=s_b+x_bi+y_bj+z_bk
$$

1.加法与减法：直接对应相加减即可

2.乘法
$$
q_aq_b=\begin{bmatrix}s_as_b-v_a^Tv_b,s_av_b+s_bv_a-v_a\times v_b\end{bmatrix}
$$
3.模长

与复数类似，四元数的模长为其各项的平方和

4.共轭

虚部取相反数即可，一个四元数与其共轭相乘，其实部为模长的平方，虚部为0

5.逆

四元数的逆为其共轭除去其模长的平方
$$
q^{-1}=\frac{q^*}{||q||^2}
$$
#### 四元数表示旋转

记一个三维空间点p，经过一个变换R变换到点p‘
$$
p'=Rp
$$
现在，由一个四元数q来指定旋转规则，现将p的三维坐标代入四元数的虚部，再通过第二式即得
$$
p=\begin{bmatrix}0,x,y,z\end{bmatrix}^T\\
p'=qpq^{-1}
$$
需要说明的是，上面的乘法都是四元数乘法，最后去除p‘中的虚部即为变换后的坐标

四元数在紧凑且无奇异性的同时也有不足，就是过于抽象。我们很难通过一个四元数直接看出坐标系做了怎样的旋转。

#### 四元数转换为旋转向量

这部分不做详细证明，毕竟各种姿态变换库都有比较好的实现
$$
\theta = 2arccoss\\
n^T=\frac{v^T}{sin\frac{\theta}{2}}
$$
s,v即为四元数的实部与虚部，反之也可以得到旋转向量到四元数的公式



## 实践板块

首先安装eigen，在ubuntu环境下，只需要直接apt安装即可

```bash
sudo apt-get install libeigen3-dev
```

然后将高翔的slambook2的仓库clone下来。地址为https://github.com/gaoxiang12/slambook2

```bash
git clone https://github.com/gaoxiang12/slambook2.git
```

接着进入ch3文件夹，编译

```bash
cd ch3
mkdir build
cd build
cmake ..
make
```

逐个运行并对照代码分析即可。

eigen的使用在代码中注释的已经很清楚了，目前只需要了解这些，剩下的部分在工程实践部分再学习。

eigen官方教程：https://eigen.tuxfamily.org/dox/index.html

后面两个例程使用了pangolin画三维图，不过我是基于ROS开发，ROS的可视化平台rviz已经足够优秀，所以仅仅简单了解一下pangolin

pangolin安装可见：https://github.com/stevenlovegrove/Pangolin

两个例程分别使用pangolin画了三维运动轨迹，以及姿态显示，这里不过多赘述



书中还提到一个实际例子

记世界坐标系W，物体1在坐标系R1下，物体2在坐标系R2下
$$
已知\quad\quad T_{1,w},T_{2,w}=[q_1,t_1],[q_2,t_2]\\
q_1=[0.35,0.2,0.3,0.1]^T,t_1=[0.3,0.1,0.1]\\
q_2=[-0.5,0.4,-0.1,0.2]^T,t_2=[-0.1,0.5,0.3]\\
现R1下观测到一点p_{R1}[0.5,0,0.2],求P_{R2}
$$
思路:
$$
p_w=T_{w,1}p_{R1}=T_{1,w}^{-1}p_{R1}\\
p_{R2}=T_{2,w}p_w
$$
代码

```C++
#include <Eigen/Core>
#include <Eigen/Geometry>

int main(int argc, char **argv) {
  Quaterniond q1(0.35, 0.2, 0.3, 0.1), q2(-0.5, 0.4, -0.1, 0.2);//初始化四元数
  //归一化
  q1.normalize();
  q2.normalize();
  //初始化平移向量和坐标点
  Vector3d t1(0.3, 0.1, 0.1), t2(-0.1, 0.5, 0.3);
  Vector3d p1(0.5, 0, 0.2);

  //由四元数初始化变换矩阵
  Isometry3d T1w(q1), T2w(q2);
  //增添平移部分
  T1w.pretranslate(t1);
  T2w.pretranslate(t2);

  Vector3d p2 = T2w * T1w.inverse() * p1;
  cout << endl << p2.transpose() << endl;
  return 0;
}
```

这就是最简单的姿态变换示例
